# [Note]Linux内核设计的艺术(v2)

> 图解Linux操作系统架构设计与实现原理

- @doc https://weread.qq.com/web/reader/eb432a1059346feb43178b3

# 第1章 从开机加电到执行main函数之前的过程

# 1.1 启动BIOS，准备实模式下的中断向量表和中断服务程序

# 1.1.1 BIOS的启动原理

# 1.1.2 BIOS在内存中加载中断向量表和中断服务程序

# 1.2 加载操作系统内核程序并为保护模式做准备

# 1.2.1 加载第一部分内核代码——引导程序（bootsect）

# 1.2.2 加载第二部分内核代码——setup

# 1.2.3 加载第三部分内核代码——system模块

# 1.3 开始向32位模式转变，为main函数的调用做准备

# 1.3.1 关中断并将system移动到内存地址起始位置0x00000

# 1.3.2 设置中断描述符表和全局描述符表

# 1.3.3 打开A20，实现32位寻址

# 1.3.4 为保护模式下执行head.s做准备

# 1.3.5 head.s开始执行

# 1.4 本章小结

# 第2章 设备环境初始化及激活进程0

# 2.1 设置根设备 -4、硬盘

# 2.2 规划物理内存格局，设置缓冲区、虚拟盘、主内存

# 2.3 设置虚拟盘空间并初始化

# 2.4 内存管理结构mem_map初始化

# 2.5 异常处理类中断服务程序挂接

# 2.6 初始化块设备请求项结构

# 2.7 与建立人机交互界面相关的外设的中断服务程序挂接

# 2.7.1 对串行口进行设置

# 2.7.2 对显示器进行设置

# 2.7.3 对键盘进行设置

# 2.8 开机启动时间设置

# 2.9 初始化进程0

# 2.9.1 初始化进程0

# 2.9.2 设置时钟中断

# 2.9.3 设置系统调用总入口

# 2.10 初始化缓冲区管理结构

# 2.11 初始化硬盘

# 2.12 初始化软盘

# 2.13 开启中断

# 2.14 进程0由0特权级翻转到3特权级，成为真正的进程

# 2.15 本章小结

# 第3章 进程1的创建及执行

# 3.1 进程1的创建

# 3.1.1 进程0创建进程1

# 3.1.2 在task[64]中为进程1 申请一个空闲位置并获取进程号

# 3.1.3 调用copy_process函数

# 3.1.4 设置进程1的分页管理

# 3.1.5 进程1共享进程0的文件

# 3.1.6 设置进程1在GDT中的表项

# 3.1.7 进程1处于就绪态

# 3.2 内核第一次做进程调度

# 3.3 轮转到进程1执行

# 3.3.1 进程1为安装硬盘文件系统做准备

# 3.3.2 进程1格式化虚拟盘并更换根设备为虚拟盘

# 3.3.3 进程1在根设备上加载根文件系统

# 3.4 本章小结

# 第4章 进程2的创建及执行

# 4.1 打开终端设备文件及复制文件句柄

# 4.1.1 打开标准输入设备文件

# 4.1.2 打开标准输出、标准错误输出设备文件

# 4.2 进程1创建进程2并切换到进程2执行

# 4.3 加载shell程序

# 4.3.1 关闭标准输入设备文件，打开rc文件

# 4.3.2 检测shell文件

# 4.3.3 为shell程序的执行做准备

# 4.3.4 执行shell程序

# 4.4 系统实现怠速

# 4.4.1 创建update进程

# 4.4.2 切换到shell进程执行

# 4.4.3 重建shell

# 4.5 本章小结

# 第5章 文件操作

# 5.1 安装文件系统

# 5.1.1 获取外设的超级块

# 5.1.2 确定根文件系统的挂接点

# 5.1.3 将超级块与根文件系统挂接

# 5.2 打开文件

# 5.2.1 将进程的*filp[20]与file_table[64]挂接

# 5.2.2 获取文件i节点

# 5.2.3 将文件i节点与file_table[64]挂接

# 5.3 读文件

# 5.3.1 确定数据块在外设中的位置

# 5.3.2 将数据块读入缓冲块

# 5.3.3 将缓冲块中的数据复制到进程空间

# 5.4 新建文件

# 5.4.1 查找文件

# 5.4.2 新建文件i节点

# 5.4.3 新建文件目录项

# 5.5 写文件

# 5.5.1 确定文件的写入位置

# 5.5.2 申请缓冲块

# 5.5.3 将指定的数据从进程空间复制到缓冲块

# 5.5.4 数据同步到外设的两种方法

# 5.6 修改文件

# 5.6.1 重定位文件的当前操作指针

# 5.6.2 修改文件

# 5.7 关闭文件

# 5.7.1 当前进程的filp与file_table[64]脱钩

# 5.7.2 文件i节点被释放

# 5.8 删除文件

# 5.8.1 对文件的删除条件进行检查

# 5.8.2 进行具体的删除工作

# 5.9 本章小结

# 第6章 用户进程与内存管理

# 6.1 线性地址的保护

# 6.1.1 进程线性地址空间的格局

# 6.1.2 段基址、段限长、GDT、LDT、特权级

# 6.2 分页

# 6.2.1 线性地址映射到物理地址

# 6.2.2 进程执行时分页

# 6.2.3 进程共享页面

# 6.2.4 内核分页

# 6.3 一个用户进程从创建到退出的完整过程

# 6.3.1 创建str1进程

# 6.3.2 str1进程加载的准备工作

# 6.3.3 str1进程的运行、加载

# 6.3.4 str1进程的退出

# 6.4 多个用户进程同时运行

# 6.4.1 进程调度

# 6.4.2 页写保护

# 6.5 本章小结

# 第7章 缓冲区和多进程操作文件

# 7.1 缓冲区的作用

# 7.2 缓冲区的总体结构

# 7.3 b_dev、b_blocknr及request的作用

# 7.3.1 保证进程与缓冲块数据交互的正确性

# 7.3.2 让数据在缓冲区中停留的时间尽可能长

# 7.4 uptodate和dirt的作用

# 7.4.1 b_uptodate的作用

# 7.4.2 b_dirt的作用

# 7.4.3 i_uptodate、i_dirt和s_dirt的作用

# 7.5 count、 lock、wait、request的作用

# 7.5.1 b_count的作用

# 7.5.2 i_count的作用

# 7.5.3 b_lock、*b_wait的作用

# 7.5.4 i_lock、i_wait、s_lock、*s_wait的作用

# 7.5.5 补充request的作用

# 7.6 实例1：关于缓冲块的进程等待队列

# 7.7 总体来看缓冲块和请求项

# 7.8 实例2：多进程操作文件的综合实例

# 7.9 本章小结

# 第8章 进程间通信

# 8.1 管道机制

# 8.1.1 管道的创建过程

# 8.1.2 管道的操作

# 8.2 信号机制

# 8.2.1 信号的使用

# 8.2.2 信号对进程执行状态的影响

# 8.3 本章小结

# 第9章 操作系统的设计指导思想

# 9.1 运行一个最简单的程序，看操作系统为程序运行做了哪些工作

# 9.2 操作系统的设计指导思想——主奴机制

# 9.2.1 主奴机制中的进程及进程创建机制

# 9.2.2 操作系统的设计如何体现主奴机制

# 9.3 实现主奴机制的三种关键技术

# 9.3.1 保护和分页

# 9.3.2 特权级

# 9.3.3 中断

# 9.4 建立主奴机制的决定性因素——先机

# 9.5 软件和硬件的关系

# 9.5.1 非用户进程——进程0、进程1、shell进程

# 9.5.2 文件与数据存储

# 9.6 父子进程共享页面

# 9.7 操作系统的全局中断与进程的局部中断——信号

# 9.8 本章小结